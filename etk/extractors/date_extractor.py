from typing import List
from enum import Enum, auto
from etk.etk import ETK
from etk.extractor import Extractor, InputType
from etk.extractors.spacy_rule_extractor import SpacyRuleExtractor
from etk.etk_extraction import Extraction
import datetime, re, dateparser, json, calendar, pytz, spacy
from tzlocal import get_localzone
from etk.extractors.date_extractor_helper import units, singleton_regex, spacy_rules, directions, num_to_digit
from dateutil.relativedelta import *

EXTRACT_FIRST_DATE_ONLY = 'extract_first_date_only'
ADDITIONAL_FORMATS = 'additional_formats'
USE_DEFAULT_FORMATS = 'use_default_formats'
IGNORE_DATES_BEFORE = 'ignore_dates_before'
IGNORE_DATES_AFTER = 'ignore_dates_after'
DETECT_RELATIVE_DATES = 'detect_relative_dates'
RELATIVE_BASE = 'relative_base'
PREFERRED_DATE_ORDER = 'preferred_date_order'
PREFER_LANGUAGE_DATE_ORDER = 'prefer_language_date_order'
TIMEZONE = 'timezone'
TO_TIMEZONE = 'to_timezone'
RETURN_AS_TIMEZONE_AWARE = 'return_as_timezone_aware'
PREFER_DAY_OF_MONTH = 'prefer_day_of_month'
PREFER_DATES_FROM = 'prefer_dates_from'

class DateResolution(Enum):
    """

    """
    SECOND = auto()
    MINUTE = auto()
    HOUR = auto()
    DAY = auto()
    MONTH = auto()
    YEAR = auto()


class DateExtractor(Extractor):
    def __init__(self, etk: ETK=None, extractor_name: str='date extractor') -> None:
        Extractor.__init__(self,
                           input_type=InputType.TEXT,
                           category="data extractor",
                           name=extractor_name)

        # The 'final_regex' and 'symbol_list' are generated by 'helper_date_regex_generator'
        # If the single regexes are changed or more patterns are added,
        # please re-generate 'final_regex' and 'symbol_list' and paste here.
        self.final_regex = {
          'MDY': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:(?:[,/ \.\-]? ?)(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th)))?(?:[,/ \.\-]? ?)(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)',
          'DMY': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th))(?:[,/ \.\-]? ?))?(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:[,/ \.\-]? ?)(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)',
          'YMD': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:[,/ \.\-]? ?)(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:(?:[,/ \.\-]? ?)(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th)))?(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)'
        }
        self.symbol_list = {
            'MDY': ['%A', '%a', '%B', '%b', '%m', '%-m', '%d', '%-d', '%d', '%-d', '%Y', '%y', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z'],
            'DMY': ['%A', '%a', '%d', '%-d', '%d', '%-d', '%B', '%b', '%m', '%-m', '%Y', '%y', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z'],
            'YMD': ['%A', '%a', '%Y', '%y', '%B', '%b', '%m', '%-m', '%d', '%-d', '%d', '%-d', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z']
          }
        self.settings = {}
        self.etk = etk

    def extract(self, text: str = None,
                extract_first_date_only: bool = False,
                # useful for news stories where the first date is typically the publication date.
                additional_formats: List[str] = list(),  # when specified, only extract the given formats.
                use_default_formats: bool = False,
                ignore_dates_before: datetime.datetime = None,
                ignore_dates_after: datetime.datetime = None,
                detect_relative_dates: bool = True,
                relative_base: datetime.datetime = None,
                preferred_date_order: str = "MDY",  # used for interpreting ambiguous dates that are missing parts
                prefer_language_date_order: bool = True,
                timezone: str = None,  # default is local timezone.
                to_timezone: str = None,  # when not specified, not timezone conversion is done.
                return_as_timezone_aware: bool = True,  # when false don't do timezime conversions.
                prefer_day_of_month: str = "first",  # can be "current", "first", "last".
                prefer_dates_from: str = "current"  # can be "current", "future", "past".
                ) -> List[Extraction]:

        if ignore_dates_before and not ignore_dates_before.tzinfo:
            ignore_dates_before = ignore_dates_before.replace(tzinfo=pytz.timezone(timezone) if timezone else get_localzone())
        if ignore_dates_after and not ignore_dates_after.tzinfo:
            ignore_dates_after = ignore_dates_after.replace(tzinfo=pytz.timezone(timezone) if timezone else get_localzone())
        if relative_base and not relative_base.tzinfo:
            relative_base = relative_base.replace(tzinfo=pytz.timezone(timezone) if timezone else get_localzone())

        self.settings = {
            EXTRACT_FIRST_DATE_ONLY: extract_first_date_only,
            ADDITIONAL_FORMATS: additional_formats,
            USE_DEFAULT_FORMATS: use_default_formats,
            IGNORE_DATES_BEFORE: ignore_dates_before,
            IGNORE_DATES_AFTER: ignore_dates_after,
            DETECT_RELATIVE_DATES: detect_relative_dates,
            RELATIVE_BASE: relative_base,
            PREFERRED_DATE_ORDER: preferred_date_order,
            PREFER_LANGUAGE_DATE_ORDER: prefer_language_date_order,
            TIMEZONE: timezone,
            TO_TIMEZONE: to_timezone,
            RETURN_AS_TIMEZONE_AWARE: return_as_timezone_aware,
            PREFER_DAY_OF_MONTH: prefer_day_of_month,
            PREFER_DATES_FROM: prefer_dates_from
        }

        results = []
        additional_regex = []
        if additional_formats:
            for date_format in additional_formats:
                order = ''
                reg = date_format
                for key in singleton_regex:
                    if key[0] == '%':
                        reg2 = re.sub(key, singleton_regex[key], reg)
                        if reg != reg2:
                            if key in units['M']:
                                order += 'M'
                            elif key in units['Y']:
                                order += 'Y'
                            elif key in units['D']:
                                order += 'D'
                            reg = reg2
                additional_regex.append({
                    'reg': reg,
                    'pattern': date_format,
                    'order': order,
                })
            for r in additional_regex:
                matches = [self.wrap_date_str(r['order'], match, pattern=r['pattern']) for match in
                           re.finditer(r['reg'], text, re.I)]
                results.append(matches)
            if use_default_formats:
                for order in self.final_regex.keys():
                    matches = [self.wrap_date_str(order, match) for match in re.finditer(self.final_regex[order], text, re.I) if match]
                    results.append(matches)
        else:
            for order in self.final_regex.keys():
                matches = [self.wrap_date_str(order, match) for match in re.finditer(self.final_regex[order], text, re.I) if match]
                results.append(matches)

        ans = self.remove_overlapped_date_str(results)

        if detect_relative_dates:
            # ans += self.extract_relative_dates(text)
            for x in self.extract_relative_dates(text):
                print(x)

        return ans

    def extract_relative_dates(self, text):
        if not text:
            return []
        base = self.settings[RELATIVE_BASE] if self.settings[RELATIVE_BASE] else datetime.datetime.now()
        res = SpacyRuleExtractor(self.etk.default_nlp, spacy_rules, 'relative_date_extractor').extract(text)
        ans = []
        for relative_date in res:
            if relative_date.rule_id == 'direction_number_unit':
                direction, measure, unit = relative_date.value.split()
                measure = num_to_digit[measure.lower()]
            elif relative_date.rule_id == 'number_unit_direction':
                measure, unit, direction = relative_date.value.split()
                measure = num_to_digit[measure.lower()]
            elif relative_date.rule_id == 'direction_digit_unit':
                direction, measure, unit = relative_date.value.split()
            elif relative_date.rule_id == 'digit_unit_direction':
                measure, unit, direction = relative_date.value.split()
            elif relative_date.rule_id == 'direction_unit':
                direction, unit = relative_date.value.split()
                measure = '1'
            elif relative_date.rule_id == 'the_day':
                unit = 'days'
                direction = '-' if relative_date.value.split()[-1].lower() == 'yesterday' else '+'
                measure = '1' if len(relative_date.value.split()) == 1 else '2'
            else:
                continue
            unit = unit if unit[-1] == 's' else unit+'s'
            direction = directions[direction.lower()] if direction.lower() in directions else (direction if direction else '+')
            delta_args = {unit: int(direction+measure)}
            relative_delta = relativedelta(**delta_args)
            ans.append({
                'original_text': relative_date.value,
                'date_object': base+relative_delta
            })
        return ans

    @staticmethod
    def wrap_date_str(order, match, pattern=None):
        return {
            'value': match.group(),
            'groups': match.groups(),
            'start': match.start(),
            'end': match.end(),
            'order': order,
            'pattern': pattern
        } if match else None

    def remove_overlapped_date_str(self, results):
        res = []
        all_results = []
        for x in results:
            all_results = all_results + x
        if not all_results or len(all_results) == 0:
            return list()
        all_results.sort(key=lambda k: k['start'])
        cur_max = all_results[0]
        for x in all_results[1:]:
            if cur_max['end'] <= x['start']:
                parsed_date = self.parse_date(cur_max)
                if parsed_date:
                    res.append(parsed_date)
                    if self.settings[EXTRACT_FIRST_DATE_ONLY]:
                        return res
                cur_max = x
            else:
                if len(x['value']) > len(cur_max['value']):
                    cur_max = x
                elif len(x['value']) == len(cur_max['value']) and x['order'] == self.settings[PREFERRED_DATE_ORDER]:
                    cur_max = x
        parsed_date = self.parse_date(cur_max)
        if parsed_date:
            res.append(parsed_date)
            if self.settings[EXTRACT_FIRST_DATE_ONLY]:
                return res
        return res

    def parse_date(self, date_info: dict,
                   ) -> datetime.datetime or None:
        """
        Args:
            date_info:

        Returns:

        """
        if date_info['pattern']:
            date = datetime.datetime.strptime(date_info['value'], date_info['pattern'])
        else:
            i = 0
            pattern = list()
            formatted = list()

            miss_day = True
            for s in date_info['groups']:
                if s:
                    p = self.symbol_list[date_info['order']][i].replace('-','')
                    if p in units['D']:
                        miss_day = False
                    pattern.append(p)
                    formatted.append(re.sub(r'[^0-9+\-]', '', s) if p == '%z' else s.strip())
                i += 1
            date = datetime.datetime.strptime('-'.join(formatted), '-'.join(pattern))
            if miss_day:
                if self.settings[PREFER_DAY_OF_MONTH] == 'current':
                    date = date.replace(day=datetime.datetime.now().day)
                elif self.settings[PREFER_DAY_OF_MONTH] == 'last':
                    date = date.replace(day=calendar.monthrange(date.year, date.month)[1])
        if not date.tzinfo:
            try:
                date = date.replace(tzinfo=pytz.timezone(self.settings[TIMEZONE]) if self.settings[TIMEZONE] else get_localzone())
            except Exception as e:
                date = date.replace(tzinfo=get_localzone())
                print('UnknownTimeZoneError for user defined timezone', self.settings[TIMEZONE])
        try:
            if (self.settings[IGNORE_DATES_BEFORE] and date < self.settings[IGNORE_DATES_BEFORE]) or \
                    (self.settings[IGNORE_DATES_AFTER] and date > self.settings[IGNORE_DATES_AFTER]):
                return None
        except Exception as e:
            print('!Exception: ', e)
            print(self.settings[IGNORE_DATES_BEFORE], self.settings[IGNORE_DATES_BEFORE].tzinfo)
            print(self.settings[IGNORE_DATES_AFTER], self.settings[IGNORE_DATES_AFTER].tzinfo)
            print(date, date.tzinfo)
        if self.settings[TO_TIMEZONE]:
            try:
                date = date.astimezone(pytz.timezone(self.settings[TO_TIMEZONE]))
            except Exception as e:
                date = date.astimezone(get_localzone())
                print(e)
                print('UnknownTimeZoneError for user defined timezone, set to local timezone', self.settings[TIMEZONE])

        try:
            e = Extraction(self.convert_to_iso_format(date), start_char=date_info['start'], end_char=date_info['end'], extractor_name=self.name)
            # need a more elegant way to do this:
            e._provenance['date_object'] = date
            e._provenance['original_text'] = date_info['value']
            return e
        except Exception as e:
            print()
            print('!Exception', e)
            print(date_info)
            return None

    @staticmethod
    def convert_to_iso_format(date: datetime.datetime, resolution: DateResolution = DateResolution.DAY):
        """  """
        try:
            if date:
                date_str = date.isoformat()
                length = len(date_str)
                if resolution == DateResolution.YEAR and length >= 4:
                    return date_str[:4]
                elif resolution == DateResolution.MONTH and length >= 7:
                    return date_str[:7]
                elif resolution == DateResolution.DAY and length >= 10:
                    return date_str[:10]
                elif resolution == DateResolution.HOUR and length >= 13:
                    return date_str[:13]
                elif resolution == DateResolution.MINUTE and length >= 16:
                    return date_str[:16]
                elif resolution == DateResolution.SECOND and length >= 19:
                    return date_str[:19]
                return date_str
        except Exception as e:
            print('Exception: {}, failed to convert {} to isoformat '.format(e, date))
            return None
        return None

# 1. extract first day only, then if we set range, still extract first date ignore the constraints or the first valid date
# 2. if date format set, strictly follow the format or add day if day is missing(support partial match?)
# 3. prefer_dates_from: do we support missing any part of the date, even if only the month/year exists, we still extract the date.
# we can support only the month exist in word and only the day with suffix nd, st, th, rd,
# not to support single year/month/day in pure number -> hard to say if it is part of the date, unless we analysis the context
# through on, at, in, to support the single number for dates
# support single day of week?
# 4. preferred language date order and preferred date order which go first: if language->language, else preferred?
# 5. timezone_aware and to_timezone
# 6. default year range -> precision, may have 887, three digits, support several centuries only?
# concept of date <-> if support missing both month and day and pure number appears
# 7.

# TODO: validate through weekday if confusing

# relative date:
# before, after, last, next
# number, half, quarter, several?, some?,
# weeks, years, days, months, hours, minutes, seconds
# now, , yesterday, tomorrow
