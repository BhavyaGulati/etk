from typing import List
from enum import Enum, auto
from etk.extractor import Extractor, InputType
from etk.etk_extraction import Extraction
import datetime, re, dateparser, json



class DateResolution(Enum):
    """

    """
    SECOND = auto()
    MINUTE = auto()
    HOUR = auto()
    DAY = auto()
    MONTH = auto()
    YEAR = auto()


class DateExtractor(Extractor):
    def __init__(self, extractor_name: str='date extractor') -> None:
        Extractor.__init__(self,
                           input_type=InputType.TEXT,
                           category="data extractor",
                           name=extractor_name)

        # The 'final_regex' and 'symbol_list' are generated by 'helper_date_regex_generator'
        # If the single regexes are changed or more patterns are added,
        # please re-generate 'final_regex' and 'symbol_list' and paste here.
        self.final_regex = {
          'MDY': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:(?:[,/ \.\-]? ?)(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th)))?(?:[,/ \.\-]? ?)(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)',
          'DMY': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th))(?:[,/ \.\-]? ?))?(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:[,/ \.\-]? ?)(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)',
          'YMD': r'(?<=\b)(?:(?:(?:(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?))(?:[,/ \.\-]? ?))?(?:([1-2][0-9][0-9][0-9])|([6-9][0-9]|[0-3][0-9]))(?:[,/ \.\-]? ?)(?:(January|February|March|April|May|June|July|August|September|October|November|December)|(Jan\.?|Feb\.?|Mar\.?|Apr\.?|Jun\.?|Jul\.?|Aug\.?|Sep(?:t?)\.?|Oct\.?|Nov\.?|Dec\.?)|(1[0-2]|0[1-9])|(1[0-2]|[1-9]))(?:(?:[,/ \.\-]? ?)(?:(3[0-1]|[1-2][0-9]|0[1-9])|(3[0-1]|[1-2][0-9]|[1-9])|(3[0-1]|[1-2][0-9]|0[1-9])(?:st|nd|rd|th)|(3[0-1]|[1-2][0-9]|[1-9])(?:st|nd|rd|th)))?(?:(?:[,/ \.\-]? ?)(?:(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(Mon\.?|Tue\.?|Wed\.?|Th(?:u(?:r(?:s?)?)?)\.?|Fri\.?|Sat\.?|Sun\.?)))?)(?:T?(?:(?:[,/ \.\-]? ?)|T)?(?:(?:(1[0-2]|0[1-9])|(1[0-2]|[1-9])|(2[0-3]|[0-1][0-9])|(2[0-3]|1[0-9]|[0-9])): ?(?:([0-5][0-9]))(?:: ?(?:([0-5][0-9])))?(?:(?:((?: ?)AM(?:\.?)|(?: ?)PM(?:\.?))))?(?:(?:[,/ \.\-]? ?)(?:(ACDT|ACST|ACT|ACT|ACWST|ADT|AEDT|AEST|AFT|AKDT|AKST|AMST|AMT|AMT|ART|AST|AST|AWST|AZOST|AZOT|AZT|BDT|BIOT|BIT|BOT|BRST|BRT|BST|BST|BST|BTT|CAT|CCT|CDT|CDT|CEST|CET|CHADT|CHAST|CHOT|CHOST|CHST|CHUT|CIST|CIT|CKT|CLST|CLT|COST|COT|CST|CST|CST|CT|CVT|CWST|CXT|DAVT|DDUT|DFT|EASST|EAST|EAT|ECT|ECT|EDT|EEST|EET|EGST|EGT|EIT|EST|FET|FJT|FKST|FKT|FNT|GALT|GAMT|GET|GFT|GILT|GIT|GMT|GST|GST|GYT|HDT|HAEC|HST|HKT|HMT|HOVST|HOVT|ICT|IDT|IOT|IRDT|IRKT|IRST|IST|IST|IST|JST|KGT|KOST|KRAT|KST|LHST|LHST|LINT|MAGT|MART|MAWT|MDT|MET|MEST|MHT|MIST|MIT|MMT|MSK|MST|MST|MUT|MVT|MYT|NCT|NDT|NFT|NPT|NST|NT|NUT|NZDT|NZST|OMST|ORAT|PDT|PET|PETT|PGT|PHOT|PHT|PKT|PMDT|PMST|PONT|PST|PST|PYST|PYT|RET|ROTT|SAKT|SAMT|SAST|SBT|SCT|SDT|SGT|SLST|SRET|SRT|SST|SST|SYOT|TAHT|THA|TFT|TJT|TKT|TLT|TMT|TRT|TOT|TVT|ULAST|ULAT|USZ1|UTC|UYST|UYT|UZT|VET|VLAT|VOLT|VOST|VUT|WAKT|WAST|WAT|WEST|WET|WIT|WST|YAKT|YEKT)|((?:UTC|GMT)(?: ?[\+\-] ?(?:(?:1[0-4]|0?[0-9])(?::?(?:00|30|45))?))?|[+-][01][0-3](?:00|30|45)|[\+\-](?:1[0-3]|0[0-9])(?:00|30|45))))?)Z?)?)(?=\b)'
        }
        self.symbol_list = {
            'MDY': ['%A', '%a', '%B', '%b', '%m', '%-m', '%d', '%-d', '%d', '%-d', '%Y', '%y', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z'],
            'DMY': ['%A', '%a', '%d', '%-d', '%d', '%-d', '%B', '%b', '%m', '%-m', '%Y', '%y', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z'],
            'YMD': ['%A', '%a', '%Y', '%y', '%B', '%b', '%m', '%-m', '%d', '%-d', '%d', '%-d', '%A', '%a',
                    '%I', '%-I', '%H', '%-H', '%M', '%S', '%p', '%Z', '%z']
          }

    def extract(self, text: str = None,
                extract_first_date_only: bool = False,
                # useful for news stories where the first date is typically the publication date.
                date_formats: List[str] = list(),  # when specified, only extract the given formats.
                ignore_dates_before: datetime.datetime = None,
                ignore_dates_after: datetime.datetime = None,
                detect_relative_dates: bool = True,
                relative_base: datetime.datetime = None,
                preferred_date_order: str = "MDY",  # used for interpreting ambiguous dates that are missing parts
                prefer_language_date_order: bool = True,
                timezone: str = None,  # default is local timezone.
                to_timezone: str = None,  # when not specified, not timezone conversion is done.
                return_as_timezone_aware: bool = True,  # when false don't do timezime conversions.
                prefer_day_of_month: str = "first",  # can be "current", "first", "last".
                prefer_dates_from: str = "current"  # can be "current", "future", "past".
                ) -> List[Extraction]:

        results = []
        for order in self.final_regex.keys():
            res = [self.wrap_date_str(order, match) for match in re.finditer(self.final_regex[order], text, re.I)]
            results.append(res)

        return self.remove_overlapped_date_str(results, preferred_date_order)

    def wrap_date_str(self, order, match):
        return {
            'value': match.group(),
            'groups': match.groups(),
            'start': match.start(),
            'end': match.end(),
            'order': order
        }

    def remove_overlapped_date_str(self, results, preferred_order="MDY"):
        res = []
        all_results = []
        for x in results:
            all_results = all_results + x
        if not all_results or len(all_results) == 0:
            return list()
        all_results.sort(key=lambda k: k['start'])
        cur_max = all_results[0]
        for x in all_results[1:]:
            if cur_max['end'] <= x['start']:
                parsed_date = self.parse_date(cur_max)
                if parsed_date:
                    res.append(parsed_date)
                cur_max = x
            else:
                if len(x['value']) > len(cur_max['value']):
                    cur_max = x
                elif len(x['value']) == len(cur_max['value']) and x['order'] == preferred_order:
                    cur_max = x
        parsed_date = self.parse_date(cur_max)
        if parsed_date:
            if parsed_date:
                res.append(parsed_date)
        # TODO: do not append if parse_date returns None
        return res


    def parse_date(self, str_date: dict,
                   date_formats: List[str] = list(),  # when specified, only extract the given formats.
                   ignore_dates_before: datetime.datetime = None,
                   ignore_dates_after: datetime.datetime = None,
                   detect_relative_dates: bool = True,
                   relative_base: datetime.datetime = None,
                   preferred_date_order: str = "MDY",  # used for interpreting ambiguous dates that are missing parts
                   prefer_language_date_order: bool = True,
                   timezone: str = None,  # default is local timezone.
                   to_timezone: str = None,  # when not specified, not timezone conversion is done.
                   return_as_timezone_aware: bool = True,  # when false don't do timezime conversions.
                   prefer_day_of_month: str = "first",  # can be "current", "first", "last".
                   prefer_dates_from: str = "current"  # can be "current", "future", "past".
                   ) -> datetime.datetime or None:
        """
        settings (): settings when parse the date:
            {
                'DATE_ORDER': 'MDY',    # default to be 'MDY', shuffled Y, M, D representing Year, Month, Date
                'STRICT_PARSING': True,
                'FUZZY': True,
                'PREFER_DAY_OF_MONTH': 'current',   # default to be 'current'; can be 'first' or 'last' instead;\
                    specify the date when the date is missing
                'PREFER_DATES_FROM': 'current_period',  # default to be 'current_period'; can be 'future', \
                    or 'past' instead; specify the date when the date is missing
                'RELATIVE_BASE': datetime.datetime(2020, 1, 1),  # default to be current date and time
                'SKIP_TOKENS_PARSER': ['t']    # default to be ['t']; a list of tokens to discard while detecting language
            }
        Args:
            str_date:
            date_formats:
            ignore_dates_before:
            ignore_dates_after:
            detect_relative_dates:
            relative_base:
            preferred_date_order:
            prefer_language_date_order:
            timezone:
            to_timezone:
            return_as_timezone_aware:
            prefer_day_of_month:
            prefer_dates_from:

        Returns:

        """
        # TODO: convert the params to settings for dateparser
        # customized_settings = {
        #     'STRICT_PARSING': False
        # }
        # try:
        #     if len(str_date) > 100:
        #         return list()
        #     str_date = str_date[:20] if len(str_date) > 20 else str_date
        #     str_date = str_date.replace('\r', '')
        #     str_date = str_date.replace('\n', '')
        #     str_date = str_date.replace('<', '')
        #     str_date = str_date.replace('>', '')
        #     parsed_date = dateparser.parse(str_date, settings=customized_settings)
        #     if parsed_date:
        #         # TODO: deal with the constraints like 'ignore_dates_after', 'ignore_dates_before'
        #         return parsed_date
        # except Exception as e:
        #     print('Exception: {}, failed to parse {} as date'.format(e, str_date))
        #     return list()
        i = 0
        pattern = list()
        formatted = list()
        # print(len(str_date['groups']), len(self.symbol_list[str_date['order']]))
        # print(str_date['groups'])
        # print(self.symbol_list[str_date['order']])
        for s in str_date['groups']:
            if s:
                pattern.append(self.symbol_list[str_date['order']][i].replace('-',''))
                formatted.append(s.strip())
            i += 1
        try:
            return {
                'value': datetime.datetime.strptime('-'.join(formatted), '-'.join(pattern)),
                'original_text': str_date['value'],
                'start': str_date['start'],
                'end': str_date['end']
            }
        except Exception as e:
            print()
            print('!Exception', e)
            print(str_date)
            print(pattern)
            print(formatted)
            return None

    @staticmethod
    def convert_to_iso_format(date: datetime.datetime, resolution: DateResolution = DateResolution.DAY):
        """  """
        # TODO: deal with the date resolution
        try:
            if date:
                dt = date.replace(minute=0, hour=0, second=0, microsecond=0)
                return dt.isoformat()
        except Exception as e:
            print('Exception: {}, failed to convert {} to isoformat '.format(e, date))
            return None
        return None



with open('date_ground_truth.txt', 'r') as f:
    text = f.read()
aaa = DateExtractor(extractor_name='test')
bbb = aaa.extract(text)
for x in bbb:
    print(x)

print(len(bbb))